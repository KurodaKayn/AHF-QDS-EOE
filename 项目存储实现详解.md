# AI调用方式统一方案

## 当前项目中的AI调用方式

项目中目前存在两种AI调用方式：

1. **直接使用`callAI`函数**（`src/constants/ai.ts`）
   - 在`src/store/quizStore.ts`中用于生成相似题目
   - 在`src/app/quiz/review/page.tsx`中用于题目解析
   - 在`src/app/quiz/convert/page.tsx`中用于题目转换（已修改为使用此方法）

2. **通过API路由代理调用**（已不再使用）
   - 路由定义在`src/app/api/ai/deepseek/route.ts`和`src/app/api/ai/alibaba/route.ts`
   - 这些路由仍然存在但已不再被前端直接调用

## 统一方案

### 1. 统一使用`callAI`函数

所有AI调用都应该使用`src/constants/ai.ts`中定义的`callAI`函数，该函数具有以下优势：

- 支持多种AI提供商（DeepSeek、阿里巴巴通义千问等）
- 统一的错误处理机制
- 支持流式响应和普通响应
- 可配置的API端点和密钥

### 2. 辅助函数

为了进一步简化调用，项目提供了以下辅助函数：

- `src/lib/aiHelper.ts`中的`callAiWithUserConfig`：自动从用户配置中获取AI提供商和密钥信息

### 3. 配置存储

AI配置信息存储采用混合方式：

- API密钥等敏感信息存储在本地localStorage中
- 提供商选择等设置可以存储在数据库的用户设置中

### 4. 未来优化建议

1. **移除冗余的API路由**：
   - 可以考虑移除`src/app/api/ai/deepseek/route.ts`和`src/app/api/ai/alibaba/route.ts`，因为它们已不再被使用
   - 或者保留这些路由作为备用方案，以应对某些环境下的跨域问题

2. **增强错误处理**：
   - 在`callAI`函数中添加更详细的错误类型区分
   - 针对不同类型的错误（网络错误、API密钥无效、配额超限等）提供更友好的用户提示

3. **缓存机制**：
   - 对于频繁使用的AI调用（如相似题目生成），可以考虑添加缓存机制
   - 可以使用localStorage或IndexedDB存储结果，减少重复调用

4. **流量控制**：
   - 添加请求限流机制，避免短时间内过多的API调用
   - 可以使用令牌桶或漏桶算法实现

## 调用示例

```typescript
// 基本调用示例
import { callAI } from '@/constants/ai';

const response = await callAI(
  'deepseek',  // AI提供商
  [  // 消息数组
    { role: 'system', content: '系统提示' },
    { role: 'user', content: '用户输入' }
  ],
  'your-api-key',  // API密钥
  'https://api.deepseek.com'  // 可选的基础URL
);

// 使用辅助函数调用
import { callAiWithUserConfig } from '@/lib/aiHelper';

const response = await callAiWithUserConfig(
  userId,  // 用户ID
  [  // 消息数组
    { role: 'system', content: '系统提示' },
    { role: 'user', content: '用户输入' }
  ]
);

// 流式响应示例
const response = await callAI(
  'deepseek',
  messages,
  apiKey,
  baseUrl,
  true,  // 启用流式响应
  (chunk) => {
    // 处理每个响应块
    console.log('收到块:', chunk);
  }
);
